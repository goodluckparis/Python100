
# 比如有如下三行代码，这三行代码是一个完整的功能
# print('Hello')
# print('你好')
# print('再见')

# 定义一个函数
# def fn():
#     print('这是我的第一个函数')
#     print('hello')
#     print('今天天气真不错')

# 打印fn
# print(fn) # <function fn at 0x10bc75430>
# print(type(fn)) # <class 'function'>
# fn()
# # 这是我的第一个函数
# fn()
# fn()
# fn()
# 这是我的第一个函数
# 这是我的第一个函数
# 这是我的第一个函数

# fn是函数对象 fn()是调用函数
# print是函数对象 print()是调用函数
# fn() #这里候函数才会执行

# 定义一个函数，可以用来求任意两个数的和

# def sum() :
#     a = 1
#     b = 1
#     print(a + b)
#
# sum()

# 定义函数时指定形参
def fn2(a , b) : # a,b,c 就是形参
    # print('a =',a)
    # print('b =',b)
    print(a,'+',b,'=',a + b)
# 调用函数时，来传递实参
fn2(10,20) # 10,20 是实参
fn2(123,456)
# a = 10
# b = 20
# 10 + 20 = 30
# 123 + 456 = 579

# 练习1
def mul(a,b,c):
    print(a * b *c)
mul(10,20,30)

def welcome(username):
    print('欢迎',username,'光临')
welcome('孙悟空')

# 定义一个函数
# 定义形参时，可以为形参指定默认值
# 指定了默认值以后，如果用户传递了参数则默认值没有任何作用
#   如果用户没有传递，则默认值就会生效
def fn(a,b,c =20):
    print('a =',a)
    print('b =',b)
    print('c =',c)

# fn(1,2,3)
# a = 1
# b = 2
# c = 3
# fn(1,2) #没有传C的实参
# a = 1
# b = 2
# c = 20  # 这个时候默认值生效了

# 实参的传递方式
# 位置参数
# 位置参数就是将对应位置的实参赋值给对应位置的形参
# 第一个实参赋值给第一个形参，第二个实参赋值给第二个形参...

# 关键字参数
# 关键字参数，可以不按照形参定义的顺序去传递，而直接根据参数名去传递参数
# 好处是只需要记住关键字参数，不用再记忆位置
# 位置参数和关键字参数可以混合使用
# 混合使用关键字和位置参数时，必须将位置参数写到前面

fn(b=1,c=2,a=3)
# a = 3
# b = 1
# c = 2

def fn2(a):
    print('a =',a)
# 函数在调用时，解析器不会检查实参的类型
# 实参可以传递任意类型的对象,什么都能作为参数，他不会检查参数的类型

b = 123
b = True
b = 'hello'
b = None
b = [1,2,3]

fn2(b)
# a = 123

def fn4(a):
    # 在函数中对形参进行重新赋值，不会影响其他的变量
    # a = 20
    # a是一个列表，
    # 如果形参执行的是一个对象，当我们通过形参去修改对象时
    #   会影响到所有指向该对象的变量 （这里a和c是指向同一个对象）
    a[0] = 30
    print('a =',id(a))


c = 10
c = [1,2,3]
fn4(c)
# a = 10
print('c =',id(c))
# c = 10

# a = 20
# c = 10

# a = [30, 2, 3]
# c = [30, 2, 3]

# a = 4307452096
# c = 4307452096
# 要考虑好是改对象还是改变量。

fn4(c.copy()) # 如果想a 和 c 独立，将c做一个浅复制,然后传的是C的副本，而不是C本身
fn4(c[:])

print('c =',id(c))
# a = 4440424768
# c = 4440424832

## 不定长参数
# 定义一个函数，可以求任意个数字的和
def sum(a,b):
    print(a +b)
# sum(123,456)
# 在定义函数时，可以在形参前边加一个*，这样这个形参将会获取到所有的实参
# 它将会将所有的实参保参保存到一个元组中
a,b,*c = (1,2,3,4,5,6)

# *a 会接受所有的位置实参，并且会将这些实参统一保存到一个元组中（装包）
def fn(*a):
    print('a =',a)
fn()
# a = ()
fn()
# fn(1,2,3,4,5)


def sum(*nums):
    # 定义一个变量，来保存结果
    result = 0
    # 遍历元组，并将元组中的数进行累加
    for n in nums :
        result += n
    print(result)

sum(123,456,789,10,20,30,40)
# 1468
# 带星号的形参只能有一个
# 带星号的参数，可以和其他的参数配合使用
# 第一个参数给a,第二个参数给b,余下的都保存到c的元组中

# 可变参数不是必须写在最后，但是注意，带*的参数后的所有参数，必须以关键字参数的形式传递
def fn2(a,b,*c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
fn2(1,2,3,4,5)
# a = 1
# b = 2
# c = (3, 4, 5)

# 第一个参数给a，余下的参数给b的元组，c必须使用关键字参数
def fn3(a,*b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
fn3(1,2,3,4,c=5) # c必须使用关键字参数
# a = 1
# b = (2, 3, 4)
# c = 5

# ----
# 所有的位置参数都给a,b和c必须使用关键字参数
def fn3(*a,b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
fn3(1,2,3,b=4,c=5) # b和c必须使用关键字参数
# a = (1, 2, 3)
# b = 4
# c = 5

# 如果在形参的开头直接写一个*,则要求我们的所有的参数必须以关键字参数的形式传递
def fn3(*,a,b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
# fn3(a=3,b=4,c=5) # a,b和c必须使用关键字参数
# 如果以后要求每个必须以关键字参数传递，就可以在前面这样加一个*

# *形参只能接受位置参数,而不能接收关键字参数
# del fn3(*a):
#     print('a =',a)
def fn3(**a):
    print('a =',a,type(a))

fn3(b=1,d=2,c=3)
# a = {'b': 1, 'd': 2, 'c': 3}
# a = {'b': 1, 'd': 2, 'c': 3} <class 'dict'>
## **形参可以接收其他的关键字参数，它会将这些参数统一保存到一个字典中
# 字典的key就是参数的名字，字典的value就是参数的值

# **形参只能有一个，并且必须写在所有参数的最后
def fn4(b,c,**a): # **a 关键字参数
    print('a =', a)
    print('b =',b)
    print('c =',c)
fn4(b=1, d=2, c=3,e=10,f=20)
# a = {'d': 2, 'e': 10, 'f': 20}
# b = 1
# c = 3

# 参数的解包（拆包）
def fn4(a,b,c):
    print('a =', a)
    print('b =', b)
    print('c =', c)
# 创建一个元组
t = (10,20,30)

# fn4(t[0],t[1],t[2])
# a = 10
# b = 20
# c = 30

# 传递实参时，也可以在序列类型的参数前添加星号，这样他会自动将序列中的元素依次作为参数传递
# 这里要求序列中元素的个数必须和形参的个数的一致
fn4(*t)
# a = 10
# b = 20
# c = 30

# 创建一个字典
d = {'a':100,'b':200,'c':300}
# 通过**来对一个字典进行解包操作
fn4(**d)
# a = 100
# b = 200
# c = 300

# 04 返回值,返回值就是函数执行以后返回的结果
# 可以通过return来指定函数的返回值
# 可以通过一个变量来接收函数的返回值

def sum(*nums):
    # 定义一个变量，来保存结果
    result = 0
    # 遍历元组，并将元组中的数进行累加
    for n in nums :
        result += n
    print(result)

# sum(123,456,789) # 1368
# return 后边跟什么值，函数就会返回什么值
# return 后边可以跟任意的对象，返回值甚至可以是一个函数
def fn():
    # return 200
    # return [1,2,3]
    # return {'k':'v'
    def fn2():
        print('hello')
    return fn2 # 返回值也可以是一个函数

r = fn() # 这个函数的执行结果就是它的返回值
# print(fn())
#print(r)
# 200
r() # hello, r也成了一个函数

# 如果仅仅写一个return 或者不写return,则相当于return None,返回一个空
def fn2():
    a = 10
    return
# 在函数中，return后的代码都不会执行
def fn3():
    print('hello')
    return # 在函数中，return后的代码都不会执行，return一旦执行，函数就自动结束
    print('abc')
r = fn3()  # hello
# print(r)
# None

def fn4():
    for i in range(5):
        if i == 3:
            # break 用来退出当前循环
            # continue 用来跳过当次循环
            return # return 用来结束函数
        print(i)
    print('循环执行完毕')
# fn4()

def sum(*nums):
    # 定义一个变量，来保存结果
    result = 0
    # 遍历元组，并将元组中的数进行累加
    for n in nums:
        result += n
    return result
r = sum(123,456,789)
print(r) # 1368

def fn5():
    return 10
# fn5 和 fn5()的区别
print(fn5) # fn5是函数对象，打印fn5实际是在打印函数对象 # <function fn5 at 0x109350940>
print(fn5()) # fn5()是在调用函数，打印fn5()实际上是在打印fn5()函数的返回值。 # 10

# 文档字符串
# hellp()是Python中的内置函数
# 通过help()函数可以查询python中的函数的用法
# 语法：help(函数对象）
# help(print) # 获取print()函数的使用说明

# 文档字符串（doc str)
# 在定义函数时，可以在函数内部编写文档字符串，文档字符串就是函数的说明
# 文档字符串非常简单，其实直接在函数的第一行写一个字符串就是文档字符串

# def fn(a,b,c):
#     '''
#     这是一个文档字符串的示例
#     函数的作用：.....
#     函数的参数：
#         a,作用、类型、默认值...
#         b,作用、类型、默认值...
#         c,作用、类型、默认值...
#     '''
#     return 10
# help(fn)

# # 增强写法 fn(a:int, b:bol, c:str='hello') -> int # int,bol,str在这里只是一个描述,描述性的，不是强制性的
#     这是一个文档字符串的示例
#     函数的作用：.....
#     函数的参数：
#         a,作用、类型、默认值...
#         b,作用、类型、默认值...
#         c,作用、类型、默认值...

# 作用域与命名空间
# 作用域（scope) 产生作用的一个区域
# 作用域指的是变量生效的一个区域
b = 20 # 全局变量
def fn():
    a = 10 # a 定用在了函数的内部，所以他的作用域就是函数内部，函数外部无法访问。
    print('函数内部：','a =',a)
    print('函数内部：','b =',b)

# fn() # 每周用一次，就产生一个函数作用域
# print('函数外部：', 'a =', a)
# print('函数外部：', 'b =', b)

# 在Python中一共有两种作用域
# 全局作用域
#   - 合局作用域在程序执行时创建，在程序执行结束时销毁
#   - 所有函数以外的区域都是全局作用域 （只要不是写在函数里边的）
#   - 在全局作用域中定义的变量，都属于全局变量，全局变量可以在程序的任意位置被访问到。

# 函数作用域
#   - 函数作用域在函数调用时创建，在调用结束时销毁
#   - 函数每调用一次就会产生一个新的函数作用域
#   - 在函数作用域中定义的变量，都是局部变量，它只能在函数内部被访问
# 变量的查找
#   - 当我们使用变量时，会优先在当前作用域中寻找该变量，如果有则使用，
#       如果没有则继续去上一级作用域中寻找
#       如果依然没有，则继续去上一级作用域中寻找，以此类推
#       直到找到全局作用域，依然没有找到，则会搪出异常
#           NameError:name 'a' is not defined

def fn2():
    a = 30
    def fn3():
        print('fn3中','a =',a)
    fn3()
# fn2()
# fn3中 a = 30
# 可以从内层往外看，但不能从全局（外）往内看 内边相对于外边是封闭的，好象俄罗斯套娃，从里边可以看到外边（指的是变量），外边看不到里边
a = 20
def fn3():
    # a = 10
    # 在函数中为变量赋值时，默认都是为局部变量赋值
    # 如果希望在函数内部修改合局变量，则需要使用global关键字，来声时变量
    global a # 声明在函数内部的使用a是全局变量，此时再去修改a时，就是在修改全局的a
    a = 10 # 修改全局变量
    print('a = ',a)
fn3()
# a = 10

# 命名空间(namespace)
# 命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间中
# 每一个作用域都会有一个它对应的命名空间
# 全局命名空间，用来保存全局变量，函数命名空间用来保存局部变量（保存函数中的变量）
# 命名空间实际上就是一个字典，是一个专门用来存储变量的字典

# locals()用来获取当前作用域的命名空间
# 如果在全局作用域中调用locals()则获取全局命名空间，如果在函数作用域中调用locals()则获取函数命名空间
# 返回的是一个字典
scope = locals() # 当前命名空间
print(scope)
# {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x1096fc490>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': '/Users/ourea/Desktop/Python3/Python100/def-函数简介.py', '__cached__': None, 'fn2': <function fn2 at 0x1097a18b0>, 'mul': <function mul at 0x1097a1820>, 'welcome': <function welcome at 0x1097a1550>, 'fn': <function fn at 0x1097a1af0>, 'b': 20, 'fn4': <function fn4 at 0x1097a1a60>, 'c': [3, 4, 5, 6], 'sum': <function sum at 0x1097a1430>, 'a': 10, 'fn3': <function fn3 at 0x1097a1b80>, 't': (10, 20, 30), 'd': {'a': 100, 'b': 200, 'c': 300}, 'r': 1368, 'fn5': <function fn5 at 0x1097a1940>, 'scope': {...}}

# print(a) # 10
# print(scope['a']) # 10
# 向scope中添加一个key-value
scope['c'] = 1000 # 向字典中添加key-value就相当于在全局中创建了一个变量（一般不建议这么做）
# print(c)

def fn4():
    a = 10
    # scope = locals() # 在函数内部调用locals（）会获取到函数的命名空间
    # scope['b'] = 20 # {'a': 10, 'b': 20} 可以通过scope来操作函数的命名空间，但是也是不建议这么做
    # globals() 函数可以用来在任意位置获取全局命名空间
    global_scope = globals()
    global_scope['a'] = 30
    # print(global_scope['a']) # 10
    # print(scope)
fn4() # {}
# {'a': 10}
print(a) # 30

# 07 递归
# 尝试求10的阶乘（10!)
# 创建一个函数，可以用来求任意数的阶乘
# 1! =1
# 2! = 1*2 = 2
# 3! = 1*2*3 = 6
# 4! = 1*2*3*4 = 24

# 创建一个变量保存结果
n = 10
for i in range(1,10):
    n *= i
print(n)
# 3628800

# 创建一个函数，可以用来求任意数的阶乘
def factorial(n):
    '''
    该函数用来求任意数的阶乘
    参数：
        n 要求阶乘的数字
    '''
# 创建一个变量，来保存结果
    result = n
    for i in range(1,n):
        result *= i
    return result

# 求10的阶乘
# print(factorial(10)) # 3628800
# print(factorial(20)) # 2432902008176640000

# 递归式的函数
# 从前有座山，山里有座庙，庙里有个老和尚讲故事，讲的什么故事呢？
#   从前有座山，山里有座庙，庙里有个老和尚讲故事，讲的什么故事呢？。。。
# 递归简单理解就是自己去引用自己！
# 递归式函数，在函数中自己调用自己！

# 无究递归，如果这个函数被调用，程序的内存会溢出，效果类同于死循环
# def fn():
#     fn()
# fn()

# 递归是我们解决问题的一种方式，它和循环很像
#   它的整体思想是，将一个大问题分解成一个个的小问题，直到问题无法分解时，再去解决问题
# 递归式函数的两个条件
#   1.基线条件
#       -问题可以被分解为的最小问题，当满足基线条件时，递归就不再执行了
#   2.递归条件
#       - 将问题继续分解的条件
# 10！= 10*9！
# 9！ = 9 * 8！
# 8！ = 8 * 7！
# ...
# 1！ = 1

def factorial():
    '''
     该函数用来求任意数的阶乘
     参数：
         n 要求阶乘的数字
     '''
    # 基线条件 判断n是否为1,如果为1则此时不能再继续递归
    if n == 1:
        # 1的阶3就是1，直接返回1
        return 1
    # 递归条件
    return n * factorial(n-1)
# 3628800





















